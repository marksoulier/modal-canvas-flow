#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';

// Read the event schema
const schemaPath = path.join(process.cwd(), 'src/data/event_schema.json');
const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf-8'));

// Generate TypeScript types
function generateTypes() {
  let output = `// Auto-generated TypeScript types from event_schema.json
// This file is automatically generated - DO NOT EDIT MANUALLY
// Run: npm run generate-types

// Simple parameter type mapping
export type ParameterType = 'number' | 'string';

// Generated event function types for each event
export type EventFunctionState = Record<string, boolean>;

// Generated parameter interfaces for each event type
`;

  // Generate parameter interfaces for each event
  schema.events.forEach((event: any) => {
    const eventType = event.type;

    // Generate event function type if event has function parts
    if (event.event_functions_parts && event.event_functions_parts.length > 0) {
      const functionTypes = event.event_functions_parts.map((f: any) => `"${f.type}"`).join(' | ');
      output += `export type ${eventType}FunctionTypes = ${functionTypes};\n\n`;

      // Generate interface for event functions state
      output += `export interface ${eventType}FunctionState extends EventFunctionState {\n`;
      event.event_functions_parts.forEach((f: any) => {
        output += `  "${f.type}"?: boolean;\n`;
      });
      output += `}\n\n`;
    }

    const interfaceName = `${eventType}Params`;
    output += `export interface ${interfaceName} {\n`;

    // Add parameters based on the event's parameters array
    if (event.parameters) {
      event.parameters.forEach((param: any) => {
        const paramType = getParamType(param.parameter_units);
        const optional = param.editable === false ? '?' : '';
        output += `  ${param.type}${optional}: ${paramType};\n`;
      });
    }

    output += `}\n\n`;

    // Generate types for updating events
    if (event.updating_events) {
      event.updating_events.forEach((updatingEvent: any) => {
        const updatingEventType = updatingEvent.type;
        // Convert spaces to underscores for valid TypeScript interface names
        const safeUpdatingEventType = updatingEventType.replace(/\s+/g, '_');

        // Generate event function type if updating event has function parts
        if (updatingEvent.event_functions_parts && updatingEvent.event_functions_parts.length > 0) {
          const functionTypes = updatingEvent.event_functions_parts.map((f: any) => `"${f.type}"`).join(' | ');
          output += `export type ${safeUpdatingEventType}FunctionTypes = ${functionTypes};\n\n`;

          // Generate interface for event functions state
          output += `export interface ${safeUpdatingEventType}FunctionState extends EventFunctionState {\n`;
          updatingEvent.event_functions_parts.forEach((f: any) => {
            output += `  "${f.type}"?: boolean;\n`;
          });
          output += `}\n\n`;
        }

        const updatingInterfaceName = `${safeUpdatingEventType}Params`;
        output += `export interface ${updatingInterfaceName} {\n`;

        if (updatingEvent.parameters) {
          updatingEvent.parameters.forEach((param: any) => {
            const paramType = getParamType(param.parameter_units);
            const optional = param.editable === false ? '?' : '';
            output += `  ${param.type}${optional}: ${paramType};\n`;
          });
        }

        output += `}\n\n`;
      });
    }
  });

  // Add the helper function to convert event.parameters to typed objects
  output += `// Helper function to convert event.parameters to typed objects
export function getTypedParams<T extends Record<string, any>>(event: any): T {
  // Handle case where parameters might already be an object (converted by parseEvents)
  if (Array.isArray(event.parameters)) {
    const params: any = {};
    event.parameters.forEach((param: any) => {
      params[param.type] = param.value;
    });
    return params as T;
  } else {
    // Parameters is already an object
    return event.parameters as T;
  }
}

// Helper function to convert updating event parameters to typed objects
export function getTypedUpdatingParams<T extends Record<string, any>>(updatingEvent: any): T {
  // Handle case where parameters might already be an object (converted by parseEvents)
  if (Array.isArray(updatingEvent.parameters)) {
    const params: any = {};
    updatingEvent.parameters.forEach((param: any) => {
      params[param.type] = param.value;
    });
    return params as T;
  } else {
    // Parameters is already an object
    return updatingEvent.parameters as T;
  }
}

// Helper function to get typed event functions state
export function getTypedEventFunctions<T extends EventFunctionState>(event: any): T {
  // Handle case where event_functions might already be an object (converted by parseEvents)
  if (Array.isArray(event.event_functions)) {
    const functions: any = {};
    event.event_functions.forEach((func: any) => {
      functions[func.type] = func.enabled;
    });
    return functions as T;
  } else {
    // event_functions is already an object
    return event.event_functions as T;
  }
}

// Type-safe event handler function type
export type EventHandler<T extends Record<string, any>> = (
  event: any, 
  envelopes: Record<string, any>
) => void;

// Convenience import for all types - just add this one line to baseFunctions.ts:
// import type * as AllEventTypes from './generated-types';
// Then use: AllEventTypes.invest_moneyParams, AllEventTypes.update_amountParams, etc.

// OR import specific types you need:
// import type { invest_moneyParams, update_amountParams, Reoccuring_Dividend_PayoutParams } from './generated-types';

// OR import everything (not recommended for large projects):
// import * as GeneratedTypes from './generated-types';
// Then use: GeneratedTypes.invest_moneyParams, GeneratedTypes.getTypedParams, etc.

// Available types in this file:
`;

  // Write to file
  const outputPath = path.join(process.cwd(), 'src/types/generated-types.ts');
  fs.writeFileSync(outputPath, output);
  console.log(`âœ… Generated types in ${outputPath}`);
}

// Helper function to determine TypeScript type from parameter units
function getParamType(parameterUnits: string): string {
  switch (parameterUnits) {
    case 'usd':
    case 'apy':
    case 'percentage':
    case 'number_per_year':
    case 'quantity':
    case 'number':
    case 'days':
    case 'hours':
    case 'years':
    case 'date':
      return 'number';
    case 'envelope':
    case 'enum':
    case 'icon':
    case 'string':
      return 'string';
    default:
      return 'number | string';
  }
}

generateTypes();
